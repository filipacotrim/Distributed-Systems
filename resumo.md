O projeto foi desenvolvido em três fases, onde em cada uma é explorada uma variante da arquitetura cliente-servidor.

Numa primeira fase, teve-se apenas em consideração um único servidor e os três tipos de cliente. Assim, procedemos à implementação do servidor com a interface de cada serviço e um sistema gRPC, que recebia os pedidos de todos os clientes. Para cada um dos clientes, foi criado um _Client Frontend_ que encapsula a interação com o servidor. Por último, para garantir a sincronização e a concorrência entre os pedidos de todos os clientes, implementámos blocos synchronized em cada pedido.

Na segunda fase, foram considerados dois tipos de servidores e, no caso do nosso grupo, são suportados vários servidores do tipo secundário. Nesta variante, os clientes podem fazer pedidos a qualquer um dos servidores, não conhecendo o endereço/porto de antemão, sendo que há operações exclusivas a um tipo de servidor. O desafio foi garantir que as operações a serem feitas concorrentemente entre vários servidores não alteram o estado do sistema, pelo que os servidores comunicavam entre si usando o protocolo _Gossip_, garantindo a consistência dos dados partilhados entre servidores. Adicionalmente, foi necessário evitar o sobrecarregamento de servidores em relação aos outros em termos de número de operações realizadas.
Ao nível da propagação do estados usando _Gossip_, concluímos que não seria necessário propagar constantemente o estado do servidor primário, mas apenas se tiverem sido realizadas operações de escrita desde a última propagação, sendo esta avaliação de propagação feita periodicamente.
Ao nível do balanceamento de carga, cada cliente, sempre que pretende realizar uma chamada remota, obtém uma lista de servidores disponíveis para realizar o tipo de operação em questão, ordenada crescentemente pelo número de operações realizadas **no mesmo cliente** (armazenadas num mapa, onde para cada endereço:porto de cada servidor corresponde o seu número de operações). O objetivo desta ordenação foi priorizar servidores com número mais baixo de operações efetuadas **em cada cliente**. Para realizar uma operação, o cliente percorre a lista até o primeiro dos servidores conseguir finalizar o pedido (se nenhum dos servidores satisfizer o pedido, a lista é percorrida uma segunda vez, e se o pedido continuar pendente inferimos que os servidores estão inativos).

Por fim, nesta terceira fase para permitir que servidor**ES** secundário**S** suportassem a operação de fazer inscrições, foi repensado o modo como a propagação dos estados era feita. Para além de, periodicamente, o servidor do tipo primário propagar o seu estado, os do tipo secundário também o passaram a fazer. Isto levou a que tivessem de ser feitas mais verificações para garantir a correta unificação e consistência dos estados.
Nomeadamente, estas verificações pediram a implementação dum novo aspeto: um relógio que é alterado a cada operação relativa a inscrições. Isto é, assumindo que os relógios dos servidores estão sincronizados, é guardado um _time stamp_ cada vez que um aluno é inscrito, um aluno é desinscrito ou as inscrições são fechadas num servidor, para na propagação do seu estado haver prioritização de inscrições mais antigas e invalidação de inscrições demasiado recentes.
